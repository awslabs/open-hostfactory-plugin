# Domain Layer - Pure Business Logic

The domain layer represents the heart of the application, containing pure business logic with zero external dependencies. This layer implements Domain-Driven Design (DDD) principles with perfect separation of concerns.

## Architecture Principles

### ✅ Zero Dependencies
- No infrastructure dependencies
- No framework dependencies  
- No cloud provider dependencies
- Pure Python business logic

### ✅ Rich Domain Models
- Business logic encapsulated in aggregates
- Behavior-rich entities (not anemic data models)
- Domain events for business state changes
- Value objects for domain concepts

### ✅ Provider-Agnostic Design
- Uses generic `provider_config` instead of cloud-specific fields
- Business rules independent of implementation details
- Ready for multi-cloud expansion

## Package Structure

### 📁 `base/` - Shared Kernel
Common domain primitives shared across all bounded contexts.

**Key Components:**
- **`entity.py`**: Base classes for entities and aggregates
- **`value_objects.py`**: Common value objects (ResourceId, InstanceId, etc.)
- **`events/`**: Domain event system directory
  - **`base_events.py`**: Base event classes and interfaces
  - **`domain_events.py`**: Core domain events
  - **`infrastructure_events.py`**: Infrastructure-related events
  - **`persistence_events.py`**: Persistence and storage events
  - **`provider_events.py`**: Provider-specific events
  - **`system_events.py`**: System-level events
- **`exceptions.py`**: Domain exception hierarchy
- **`repository.py`**: Repository interface contracts
- **`domain_interfaces.py`**: Core domain contracts (Factory, Specification, etc.)

**Shared Value Objects:**
- `ResourceId`: Unique resource identifier
- `InstanceId`: Cloud instance identifier
- `InstanceType`: VM instance type specification
- `Tags`: Key-value metadata tags
- `ProviderConfig`: Generic provider configuration

### 📁 `template/` - Template Bounded Context
Manages VM template definitions and configurations.

**Aggregate Root:**
- **`Template`**: VM template with configuration and validation

**Key Components:**
- **`aggregate.py`**: Template aggregate with business logic
- **`value_objects.py`**: Template-specific value objects
- **`events.py`**: Template domain events
- **`exceptions.py`**: Template-specific exceptions
- **`repository.py`**: Template repository interface

**Business Rules:**
- Template validation and configuration management
- Provider-specific template resolution
- Template availability and compatibility checks

### 📁 `machine/` - Machine Bounded Context
Manages individual machine instances and their lifecycle.

**Aggregate Root:**
- **`Machine`**: Individual machine instance with state management

**Key Components:**
- **`aggregate.py`**: Machine aggregate with lifecycle management
- **`value_objects.py`**: Machine-specific value objects (MachineStatus, etc.)
- **`events.py`**: Machine domain events
- **`exceptions.py`**: Machine-specific exceptions
- **`repository.py`**: Machine repository interface

**Business Rules:**
- Machine state transitions and validation
- Machine health monitoring and status tracking
- Machine termination and cleanup logic

### 📁 `request/` - Request Bounded Context
Manages provisioning requests and their orchestration.

**Aggregate Root:**
- **`Request`**: Provisioning request with workflow management

**Key Components:**
- **`aggregate.py`**: Request aggregate with workflow logic
- **`value_objects.py`**: Request-specific value objects (RequestStatus, RequestType)
- **`events.py`**: Request domain events
- **`exceptions.py`**: Request-specific exceptions
- **`repository.py`**: Request repository interface

**Business Rules:**
- Request validation and processing logic
- Request state management and transitions
- Request timeout and error handling
- Machine allocation and deallocation workflows

## Domain Events System

### Event-Driven Architecture
The domain layer generates events for all significant business state changes:

**Template Events:**
- `TemplateCreatedEvent`: New template registered
- `TemplateUpdatedEvent`: Template configuration changed
- `TemplateDeletedEvent`: Template removed

**Machine Events:**
- `MachineCreatedEvent`: New machine provisioned
- `MachineStatusChangedEvent`: Machine state transition
- `MachineTerminatedEvent`: Machine destroyed

**Request Events:**
- `RequestCreatedEvent`: New provisioning request
- `RequestStatusChangedEvent`: Request state transition
- `RequestCompletedEvent`: Request finished (success/failure)

### Event Publishing
- Events are generated by aggregates during business operations
- Repository layer extracts and publishes events automatically
- Event handlers in application layer respond to business events

## Value Objects Design

### Immutable Domain Concepts
All value objects are immutable and represent domain concepts:

```python
@dataclass(frozen=True)
class InstanceId:
    """Cloud provider instance identifier."""
    value: str
    
    def __post_init__(self):
        if not self.value or not self.value.strip():
            raise ValueError("Instance ID cannot be empty")

@dataclass(frozen=True)
class Tags:
    """Key-value metadata tags."""
    value: Dict[str, str]
    
    def __post_init__(self):
        # Validation logic for tags
        pass
```

### Provider-Agnostic Design
Value objects use generic names instead of cloud-specific terms:
- `provider_config` instead of `aws_config`
- `InstanceId` instead of `EC2InstanceId`
- `ResourceId` instead of `AWSResourceId`

## Aggregate Design

### Rich Business Logic
Aggregates encapsulate business behavior and maintain consistency:

```python
class Request(AggregateRoot):
    """Request aggregate managing provisioning workflows."""
    
    def complete_successfully(self, machine_ids: List[str]) -> None:
        """Complete request with successful machine provisioning."""
        if self.status != RequestStatus.IN_PROGRESS:
            raise InvalidRequestStateError(
                f"Cannot complete request in {self.status} state"
            )
        
        self.machine_ids = machine_ids
        self.status = RequestStatus.COMPLETED
        self.completed_at = datetime.utcnow()
        
        # Generate domain event
        self._add_domain_event(RequestCompletedEvent(
            request_id=self.request_id,
            machine_ids=machine_ids,
            completed_at=self.completed_at
        ))
```

### Consistency Boundaries
Each aggregate maintains its own consistency boundary:
- **Template**: Template configuration consistency
- **Machine**: Individual machine state consistency  
- **Request**: Request workflow consistency

## Repository Interfaces

### Domain-Driven Contracts
Repository interfaces define domain-focused contracts:

```python
class RequestRepository(ABC):
    """Repository interface for Request aggregates."""
    
    @abstractmethod
    async def save(self, request: Request) -> None:
        """Save request aggregate."""
        pass
    
    @abstractmethod
    async def find_by_id(self, request_id: RequestId) -> Optional[Request]:
        """Find request by ID."""
        pass
    
    @abstractmethod
    async def find_by_status(self, status: RequestStatus) -> List[Request]:
        """Find requests by status."""
        pass
```

### Event Publishing Integration
Repositories automatically handle domain event publishing:
- Extract events from aggregates after save operations
- Publish events to application layer handlers
- Maintain event ordering and consistency

## Exception Hierarchy

### Domain-Specific Exceptions
Each bounded context defines its own exception hierarchy:

```python
class DomainException(Exception):
    """Base domain exception."""
    pass

class TemplateException(DomainException):
    """Template-related domain exception."""
    pass

class InvalidTemplateConfigurationError(TemplateException):
    """Template configuration is invalid."""
    pass
```

## Business Rules Examples

### Template Validation
```python
def validate_template_configuration(self) -> None:
    """Validate template configuration against business rules."""
    if not self.image_id:
        raise InvalidTemplateConfigurationError("Template must have an image ID")
    
    if not self.instance_type:
        raise InvalidTemplateConfigurationError("Template must specify instance type")
    
    if self.min_count > self.max_count:
        raise InvalidTemplateConfigurationError("Min count cannot exceed max count")
```

### Request State Transitions
```python
def transition_to_in_progress(self) -> None:
    """Transition request to in-progress state."""
    if self.status != RequestStatus.PENDING:
        raise InvalidRequestStateTransitionError(
            f"Cannot transition from {self.status} to IN_PROGRESS"
        )
    
    self.status = RequestStatus.IN_PROGRESS
    self.updated_at = datetime.utcnow()
    
    self._add_domain_event(RequestStatusChangedEvent(
        request_id=self.request_id,
        old_status=RequestStatus.PENDING,
        new_status=RequestStatus.IN_PROGRESS
    ))
```

## Integration with Other Layers

### Application Layer Integration
- Application services orchestrate domain aggregates
- Command handlers invoke domain methods
- Query handlers read domain state
- Event handlers respond to domain events

### Infrastructure Layer Integration
- Repository implementations persist domain aggregates
- Event publishers handle domain events
- Configuration adapters provide domain configuration

### Provider Layer Integration
- Providers implement domain interfaces
- Provider-specific logic isolated from domain
- Domain remains cloud-agnostic

## Testing Strategy

### Unit Testing
- Test domain logic in isolation
- Mock external dependencies
- Focus on business rule validation
- Test event generation

### Domain Testing Patterns
```python
def test_request_completion():
    """Test request completion business logic."""
    # Arrange
    request = Request.create_new_request(
        template_id="template-1",
        machine_count=2
    )
    request.transition_to_in_progress()
    
    # Act
    request.complete_successfully(["machine-1", "machine-2"])
    
    # Assert
    assert request.status == RequestStatus.COMPLETED
    assert request.machine_ids == ["machine-1", "machine-2"]
    assert len(request.get_domain_events()) == 3  # Created, InProgress, Completed
```

## Future Extensions

### Adding New Bounded Contexts
1. Create new package under `domain/`
2. Define aggregate root with business logic
3. Add value objects and domain events
4. Create repository interface
5. Define domain exceptions

### Multi-Cloud Support
The domain layer is already provider-agnostic:
- Add new provider implementations in `providers/`
- Domain logic remains unchanged
- Business rules apply across all providers

---

This domain layer represents the core business value of the application, implementing sophisticated business logic while maintaining complete independence from technical concerns.
